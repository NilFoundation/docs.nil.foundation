import GitHubButton from '@site/src/components/GitHubButton'

# What is zkLLVM?

## Definition

<GitHubButton Url='https://github.com/NilFoundation/zkllvm' />

zkLLVM is a compiler that transforms C++ or Rust code into circuits to be used in zk-SNARK or zk-STARK systems.

The goal of zkLLVM is to make zero-knowledge proofs and provable computations accessible for everyone with knowledge of C++ or Rust programming.

zkLLVM takes code, breaks it down into circuit components, and transforms it into an arithmetic constraint system that can be used to generate and verify proofs when given public and private inputs.

Circuits generated by zkLLVM are compatible with the [**Placeholder proof system**](https://nil.foundation/blog/post/placeholder-proofsystem). To learn more about how zkLLVM can be extended to other proof systems, [**click here**](./key-components-tools#assigner).

:::info[Placeholder proof system]

The Placeholder system is PLONKish. The circuit components for this system are supplied from =nil; Foundation's [**blueprint library**](https://github.com/NilFoundation/zkllvm-blueprint).

:::

:::tip[Recommended specs]

The following specs are recommended for working with zkLLVM.

- A Unix kernel (an Ubuntu distribution is preferable)
- At least 64 GBs of RAM

If you are using a Windows machine, an Ubuntu distribution can be accessed via [**the WSL 2 service**](https://learn.microsoft.com/en-us/windows/wsl/install).

:::

## Pipeline

### Overview

The following diagram outlines the key components and stages of the zkLLVM circuit generation pipeline. Note that some of these components are currently unsupported.

```mermaid
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'primaryColor': '#0f0f0f',
      'primaryTextColor': '#f1f1f1',
      'primaryBorderColor': '#f1f1f1',
      'lineColor': '#87B6FC',
      'secondaryColor': '#f1f1f1',
      'tertiaryColor': '#2f2f2f',
    },
    'flowchart':
    {
        'defaultRenderer': 'elk',
        'curve': 'step'
    }
  }
}%%
flowchart TB
    classDef subgraphTitleHidden display: none;
    Initial:::subgraphTitleHidden
    classDef subgraphTitle margin-right: 650px;
    classDef subgraphTitleSDK margin-right: 250px;
    Backend:::subgraphTitle
    zkLLVM:::subgraphTitle
    SDK:::subgraphTitleSDK
    Assigner:::subgraphTitle
    Final:::subgraphTitleHidden
    CPP(C++ code)
    RUST(Rust code)
    NN(Neural network in ONNX format)
    RUSTSDK(Rust SDK)
    CPPSDK(C++ SDK)
    SQL(SQL statement)
    CLANGFRONT(Clang frontend)
    RUSTFRONT(Rust frontend)
    SQLFRONT(SQL frontend)
    ONNXFRONT(ONNX frontend)
    LLVMIR(LLVM IR)
    R1CS(Blueprint R1CS subtarget)
    PLONK(Blueprint PLONK subtarget)
    AIR(Blueprint AIR subtarget)
    R1CSASS(Blueprint R1CS assigner)
    PLONKASS(Blueprint PLONK assigner)
    AIRASS(Blueprint AIR assigner)
    R1CSPS(R1CS-compatible proof system)
    PLCPS(Placeholder proof system)
    AIRPS(AIR-compatible proof system)
    CPP --> CPPSDK
    RUST --> RUSTSDK
    CPPSDK --> CLANGFRONT
    RUSTSDK --> RUSTFRONT
    SQL --> SQLFRONT
    NN --> ONNXFRONT
    CLANGFRONT --> LLVMIR
    RUSTFRONT --> LLVMIR
    SQLFRONT --> LLVMIR
    ONNXFRONT --> LLVMIR
    LLVMIR --> R1CS
    LLVMIR --> PLONK
    LLVMIR --> AIR
    R1CS --> R1CSASS
    PLONK --> PLONKASS
    AIR --> AIRASS
    R1CSASS --> R1CSPS
    AIRASS --> AIRPS
    R1CSASS --> PLCPS
    PLONKASS --> PLCPS
    AIRASS --> PLCPS
    subgraph Initial
    CPP
    RUST
    SQL
    NN
    end
    subgraph SDK
    CPPSDK
    RUSTSDK
    end
    subgraph zkLLVM
    CLANGFRONT
    RUSTFRONT
    SQLFRONT
    ONNXFRONT
    LLVMIR
    end
    subgraph Backend
    R1CS
    PLONK
    AIR
    end
    subgraph Assigner
    R1CSASS
    PLONKASS
    AIRASS
    end
    subgraph Final
    R1CSPS
    PLCPS
    AIRPS
    end
```

### Step-by-step

Working with zkLLVM involves the following steps.

#### Write the code in C++ or Rust

There is no need to use any special syntax when working with zkLLVM. A circuit is defined by simply adding a `[[circuit]]` (C++) or a `#[circuit]` (Rust) directive before a function. With some modifications, almost any existing C++ or Rust code can be reused for zkLLVM.

:::tip[Examples]

The [**zkLLVM repository**](https://github.com/NilFoundation/zkllvm) contains several ready-made examples of circuits. They can be reused wholly or repurposed depending on the use case.

:::

:::info[Limitations]

[**Click here**](../circuit-development/limitations) to learn more about the changes that would need to be made to existing C++ or Rust code for reuse in zkLLVM.

:::

#### Compile the code into a circuit

Compiling takes only a few seconds and the entire process is done via a CLI tool which is a replacement for `clang` and `rustc`. This tool can be easily integrated to a CI/CD pipeline or any development environment.

#### Pass the circuit to the `assigner` tool

The `assigner` tool is used to prepare all inputs and witnesses for the circuit.

After this stage is complete, the circuit should be ready for use with dynamic inputs.
